# Chapter04. 所有権を理解する
## 4.3. スライス型
所有権を持たない方法として参照があるが、同様に所有権を持たないデータ型としてスライスがある。  
コレクション全体ではなく、その内の一部の要素を参照することができる。
### 文字列スライス
文字列スライスとは`String`の一部への参照であり（全体への参照ではない）、以下のように生成される。
```Rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
```
`[starting_index..ending_index]`と指定することでスライスを生成できる。
* starting_index: スライスの最初の位置
* ending_index: スライスの終端位置よりも1大きい値（starting_index + スライスの長さ）

内部的にスライスは、開始地点と長さを保持している。  
`let world = &s[6..11];`では、`world`は`s`の（1から数えて）7バイト目へのポインタと5という長さを保持する。

<img src="https://doc.rust-jp.rs/book-ja/img/trpl04-06.svg" width="25%" title="文字列スライス">

`..`という範囲記法を用いると、数値の省略が可能。
```Rust
&s[0..2] と &s[..2] は最初の番号（ゼロ）から始める意味で等価。
&s[3..len] と &s[3..] は最後のバイトを含む意味で等価。
&s[0..len] と &s[..] は文字列全体のスライスを得られる意味で等価。
```
スライスで文字列の一部要素を参照している場合に、スライス元の文字列を`clear`等で空にしようとすると、  
不変参照があるにもかかわらず可変参照を得ようとしているためエラーになる。  
コンパイラが`String`への参照が有効なことを保証してくれる。

文字列スライスを意味する型は、`&str`と記述する。
### 文字列リテラルはスライスである
```Rust
let s = "Hello, world!";
```
文字列はバイナリに埋め込まれる。  
ここで`s`の型は`&str`であり、バイナリの特定位置を指すスライスである。  
文字列が不変である理由になっており、要するに`&str`は不変な参照なのである。
### 引数としての文字列スライス
以下のように引数の型に文字列スライスを使用する。
