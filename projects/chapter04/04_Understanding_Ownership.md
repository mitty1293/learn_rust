# Chapter04. 所有権を理解する
## 4.1. 所有権とは？
### 所有権規則
* Rustの各値は、所有者と呼ばれる変数と対応している。
* いかなる時も所有者は一つである。
* 所有者がスコープから外れたら、値は破棄される。
### 変数スコープ
スコープ: 要素が有効になるプログラム内の範囲のこと
### String型
例として`String`型の所有権について考えていく。  
Rustでは文字列を表現するのに`文字列リテラル`と`String`型がある。
* 文字列リテラル
    * 不変である（イミュータブル）
* String
    * `mut`を用いて可変化できる（ミュータブル）
    * コンパイル時にサイズ不明なテキストも保持可能（ヒープにメモリを確保するため）

`String`は可変化できるのにリテラルができないのは何故か？答えはメモリを扱う方法にある。
### メモリと確保
* 文字列リテラルの場合
    * 中身はコンパイル時に判明している。
    * よってテキストは最終的なバイナリにハードコードされる。
    * コンパイル時にサイズ不明、実行時に可変なテキスト用のメモリをバイナリに確保することは不可能
        * バイナリファイル内に一定のバイト数を持っておき、バイナリファイルを実際のメモリに展開した際、持っておいたバイト分メモリを確保することになるってことか？
* `String`型の場合
    * コンパイル時に不明瞭のメモリを**ヒープ**に確保できる。
    * メモリは実行時にOSに要求される。
    * `String`型を使い終わったらOSにメモリを返還する。そしてその方法が必要になる。
* メモリを返還する方法
    * GCがある場合：GCが使用しないメモリを片付けるため人間が考慮する必要はない。
    * GCが無い場合：明示的に返還するコードを書く必要がある。
    * Rustの場合：GCは無い。メモリを所有している変数がスコープを抜けたら自動的に返還される。
        * 具体的には閉じ括弧`}`で、自動的に返還する関数`drop`が呼び出される。
### 変数とデータの相互作用法: ムーブ
`String`型の例を以下コードに示す。
```Rust
let s1 = String::from("hello");
let s2 = s1;
```
ここで`String`型の変数`s1`は以下図4-1の構造をしている。
* 3つの部品でできており、これらはスタックに保持される。
    * 文字列の中身を保持するメモリへのポインタ
    * 長さ：`String`型の中身が現在使用しているメモリ量(byte)
    * 許容量：`String`型がOSから受け取った全メモリ量(byte)
* 文字列の中身はヒープ上のメモリに保持される。

<img src="https://doc.rust-jp.rs/book-ja/img/trpl04-01.svg" alt="図4-1" width="25%" title="図4-1">

`s1`を`s2`に代入すると`String`型のデータがコピーされる。  
スタックにあるポインタ、長さ、 許容量をコピーし、ポインタが指すヒープ上のデータはコピーしない。  
図4-2のようになる。

<img src="https://doc.rust-jp.rs/book-ja/img/trpl04-02.svg" alt="図4-2" width="25%" title="図4-2">

## 参考資料
https://zenn.dev/toga/books/rust-atcoder/viewer/23-string